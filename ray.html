<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - lights - rect area light</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>
		<div click="init()">
			Init
		</div>
		<div id="svgContainer" style="display:none;"> </div>
		<div id="svgPathContainer" style="display:none;"> </div>
		<div id="svgTextContainer" style="display:none;"> </div>
		<script src="https://code.jquery.com/jquery-1.12.4.js"></script>
<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.119.1/build/three.module.js';

import {
  OrbitControls
} from 'https://cdn.jsdelivr.net/npm/three@0.119.1/examples/jsm/controls/OrbitControls.js';
import {
  GLTFLoader
} from 'https://cdn.jsdelivr.net/npm/three@0.119.1/examples/jsm/loaders/GLTFLoader.js';
import {
  RGBELoader
} from 'https://cdn.jsdelivr.net/npm/three@0.119.1/examples/jsm/loaders/RGBELoader.js';

import {
  OBJLoader
} from 'https://cdn.jsdelivr.net/npm/three@0.119.1/examples/jsm/loaders/OBJLoader.js';


var container, stats, controls;
var camera, scene, renderer,light;

var raycaster, mouse;

var manager = new THREE.LoadingManager();
const windowHalf = new THREE.Vector2( window.innerWidth / 2, window.innerHeight / 2 );
var width = window.innerWidth;
var height = window.innerHeight;
if(width < height)
{
	height = width;
}
var pixelRatio = window.devicePixelRatio;

init();
render();

function init() {

  container = document.createElement('div');
  document.body.appendChild(container);

  camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.25, 20);
  camera.position.set(-1.8, 0.9, 2.7);

  scene = new THREE.Scene();

  raycaster = new THREE.Raycaster();
  mouse = new THREE.Vector2()

  new RGBELoader()
    .setDataType(THREE.UnsignedByteType)
    .setPath('https://threejs.org/examples/textures/equirectangular/')
    .load('royal_esplanade_1k.hdr', function(texture) {

      var envMap = pmremGenerator.fromEquirectangular(texture).texture;

      scene.background = envMap;
      scene.environment = envMap;

      texture.dispose();
      pmremGenerator.dispose();

      // model

      var loader = new GLTFLoader().setPath('https://threejs.org/examples/models/gltf/DamagedHelmet/glTF/');
      loader.load('DamagedHelmet.gltf', function(gltf) {

        gltf.scene.traverse(function(child) {

          if (child.isMesh) {

            child.material.envMap = envMap;

          }

        });

        //scene.add(gltf.scene);
        
        render();

      });

    });

	//Add Cube

	let bmaterial = new THREE.MeshPhongMaterial( {
					color: 0xdddddd,
					shininess: 150,
					specular: 0x222222
				} );
				let bgeometry = new THREE.BoxGeometry( 20, 30, 5 );
				let lcube = new THREE.Mesh( bgeometry, bmaterial );
				lcube.position.set( -1, 0, -1 );
				lcube.castShadow = true;
				lcube.receiveShadow = true;
				scene.add( lcube );
				let bcmaterial = new THREE.MeshPhongMaterial( {
					color: 0xff0000,
					shininess: 150,
					specular: 0x222222
				} );
				let cube = new THREE.Mesh( bgeometry, bcmaterial );
				cube.position.set( 0, 0, -100 );
				cube.castShadow = true;
				cube.receiveShadow = true;
				scene.add( cube );
				let brmaterial = new THREE.MeshPhongMaterial( {
					color: 0xffffff,
					shininess: 150,
					specular: 0x222222
				});
				
				let rcube = new THREE.Mesh( bgeometry, brmaterial );
				rcube.position.set( 30, 0, -100 );
				rcube.castShadow = true;
				rcube.receiveShadow = true;
				scene.add( rcube );
				

	// Add product
	addProduct('men',1,2,0,0);
	
	//Light
	scene.add(new THREE.AmbientLight(0x666666));
	
	light = new THREE.DirectionalLight(0xdfebff, 0.3);
	light.position.set(500, 100, 80);
	
	
	light.castShadow = true;

	light.shadow.mapSize.width = 1024;
	light.shadow.mapSize.height = 1024;

	var d = 300;

	light.shadow.camera.left = -d;
	light.shadow.camera.right = d;
	light.shadow.camera.top = d;
	light.shadow.camera.bottom = -d;

	light.shadow.camera.far = 100;
	light.shadowDarkness = 0.5;
	light.shadowCameraVisible = true;
	scene.add(light);
	
  renderer = new THREE.WebGLRenderer({
    antialias: true
  });
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 1;
  renderer.outputEncoding = THREE.sRGBEncoding;
  container.appendChild(renderer.domElement);

  var pmremGenerator = new THREE.PMREMGenerator(renderer);
  pmremGenerator.compileEquirectangularShader();

  controls = new OrbitControls(camera, renderer.domElement);
  controls.addEventListener('change', render); // use if there is no animation loop
  controls.minDistance = 2;
  controls.maxDistance = 10;
  controls.target.set(0, 0, -0.2);
  controls.update();

  window.addEventListener('resize', onWindowResize, false);
  renderer.domElement.addEventListener( 'mousemove', onMouseMove, false );
  renderer.domElement.addEventListener('click', onClick, false);

}

function onClick() {

  event.preventDefault();

  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

  raycaster.setFromCamera(mouse, camera);

  var intersects = raycaster.intersectObject(scene, true);
  console.log(intersects);
  if (intersects.length > 0) {
	
		var object = intersects[0].object;

    object.material.color.set( Math.random() * 0xffffff );

  }
	
	render();

}

	function onMouseMove( event ) {

	event.preventDefault();
	/*mouse.x = ( event.clientX - windowHalf.x );
	mouse.y = ( event.clientY - windowHalf.y );*/
	mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

  raycaster.setFromCamera(mouse, camera);

  var intersects = raycaster.intersectObject(scene, true);
  console.log(intersects);
  if (intersects.length > 0) {
	
		var object = intersects[0].object;

    object.material.color.set( Math.random() * 0xffffff );

  }
	
	render();
	


}
function onWindowResize() {

  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();

  renderer.setSize(window.innerWidth, window.innerHeight);
  
  render();

}


function render() {

  renderer.render(scene, camera);

}

function addProduct(g,c,p,x,rx){
    
	loadSvg(g,c,p,function(resp){
	obj2_model_load(g+'/cat'+c+'/model',resp,x,rx);
	
	});
	
}
function loadSvg(g,c,p,response){
$.get('assets/'+g+'/cat'+c+'/prod'+p+'/pattern.svg', function(data) {  
	var svgData = new XMLSerializer().serializeToString(data.documentElement);
	$('#svgContainer').empty();
	$('#svgContainer').append(svgData).html();
		set_materials(g,c,p,svgData,function(resp){
		  response(resp);
		});
	});
}
function set_materials(g,c,p,svgData,response){
	
	var baseSvg = document.getElementById("svgContainer").querySelector("svg");
	var baseSvgData = (new XMLSerializer()).serializeToString(baseSvg);
	
	$('#svgPathContainer').empty();
	$('#svgTextContainer').empty();
	$('#svgPathContainer').append(baseSvgData).html();
	$('#svgTextContainer').append(baseSvgData).html();
	var texts = $('#svgPathContainer text');
	for(var i = 0;i < texts.length; i++){
	 $(texts[i]).remove();
	}
	var paths = $('#svgTextContainer path');
	for(var i = 0;i < paths.length; i++){
	 $(paths[i]).remove();
	}
	
	var svg = document.getElementById("svgPathContainer").querySelector("svg");
	//var svgData = (new XMLSerializer()).serializeToString(svg);
	var canvas = document.createElement("canvas");
	canvas.width = $(svg).width();
	canvas.height = $(svg).height();
	var ctx = canvas.getContext("2d");

	var img = document.createElement("img");
	var material;
	img.setAttribute("src", "data:image/svg+xml;base64," + window.btoa(unescape(encodeURIComponent(svgData))) );

	img.onload = function() {
	  ctx.drawImage(img, 0, 0);
	  var oImg = document.createElement("img");
	  oImg.width = "100px";
	  oImg.height = "100px";
	  oImg.setAttribute("src", 'assets/'+g+'/cat'+c+'/texture.png');
	  oImg.onload = function(){
			ctx.globalAlpha = 0.4;
			ctx.scale(0.3,0.3);
			var pattern = ctx.createPattern(oImg,'repeat');
			ctx.fillStyle = pattern;
			ctx.fillRect(0, 0, canvas.width*3.33, canvas.height*3.33);
			ctx.globalAlpha = 1;
			ctx.scale(3.33,3.33);
			//var svgText = document.getElementById("svgTextContainer").querySelector("svg");
			//var svgTextData = (new XMLSerializer()).serializeToString(svgText);
			var svgTextData = svgData;
			
			var imgT = document.createElement("img");
			imgT.setAttribute("src", "data:image/svg+xml;base64," + window.btoa(unescape(encodeURIComponent(svgTextData))) );
			imgT.onload = function() {
			      ctx.drawImage(imgT, 0, 0);		
				  var texture = new THREE.Texture(canvas);
				  texture.needsUpdate = true;
				  var tmap = texture;
				  //textureMaterial = new THREE.MeshPhongMaterial({map: map});
				  let tm = new THREE.MeshPhongMaterial({map: tmap});
				  //load_materials();
				  response(tm);
			}
	  }
	};
}

function load_materials()
{
	var paths = $('#svgContainer path');
	console.log('paths',paths.length);
	var materialContainer = '';
	for(var i=0; i< paths.length;i++){
	var bg = $(paths[i]).attr('fill');
	var id = $(paths[i]).attr('id');
	if(bg != undefined && id != undefined){		
	var data = id.split('(')[1].split(')')[0];	
	var selected = (selectedMaterial == id)?'active':'';	
	materialContainer += '<div id="mat_'+data+'" class="xixcust '+ selected +'" onclick="selectMaterial(\''+id+'\')"><span class="molids" style="background:'+bg+'"></span><span class="egseas">'+id+'</span></div>';
	}
	}
	load_texts();
	
  $('.materials').empty();
  $('.materials').append(materialContainer).html();
}

//model = "men/cat1";
function obj2_model_load(model,resp,x,rx){
console.log(resp);
var loader = new OBJLoader(manager); 
loader.load('./assets/'+model+'.obj', function ( data ) {
		//if(object != null){
		//scene.remove(object);
		//}
		//object = null;
		console.log(data);
		let tdobject = new THREE.Object3D();
		//tdobject = data.detail.loaderRootNode	;
		tdobject = data	;
		console.log(tdobject);
		let materials =[];
		tdobject.traverse( function ( node ) {
			if ( node.isMesh ) {
			
				node.material = resp
				node.geometry.uvsNeedUpdate = true;	
				//object = node;
				
			
			}
		}); 
		var scale = height/4;
		//tdobject.scale.set(scale, scale, scale);
		tdobject.scale.set(1, 1, 1);
		//tdobject.position.set(0,-scale*1.5, 0);
		
		//tdobject.position.set(x,-scale*1.5, 0);
		tdobject.position.set(0,-1.5, 0);
		tdobject.rotation.set(0, 0, 0);
		//tdobject.rotation.set(0, 0, 0);
		tdobject.receiveShadow = true;
		tdobject.castShadow = true;		
		scene.add(tdobject);
		render();
		//console.log("scene",scene);
 });
}

</script>
</body>
</html>
